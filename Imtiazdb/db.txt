-- Full Supabase Schema for a PUBLIC GST Management System
-- WARNING: This schema is designed for a fully public, anonymous-write database.
-- It removes user-specific data ownership, allowing ANYONE to create, read, update, and delete data.
-- Do NOT use this schema for sensitive or private data.
--
-- To use, copy and paste the entire script into the Supabase SQL Editor and run it.

-- 0. Types
-- The `invoice_status` ENUM is no longer needed and should be dropped if it exists.
DROP TYPE IF EXISTS public.invoice_status;


-- 1. Tables
-- The `user_id` column is now nullable to allow anonymous data entry.

-- Company Details Table (SINGLETON)
CREATE TABLE public.company_details (
    id smallint NOT NULL DEFAULT 1,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text,
    address text,
    gstin text,
    pan text,
    account_name text,
    account_number text,
    account_type text,
    bank_name text,
    ifsc_code text,
    CONSTRAINT company_details_pkey PRIMARY KEY (id),
    CONSTRAINT company_details_singleton_check CHECK (id = 1)
);
ALTER TABLE public.company_details ENABLE ROW LEVEL SECURITY;

-- Customers Table
CREATE TABLE public.customers (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    email text,
    phone text,
    gstin text,
    billing_address text,
    is_guest boolean NOT NULL DEFAULT false,
    CONSTRAINT customers_pkey PRIMARY KEY (id),
    CONSTRAINT customers_name_key UNIQUE (name)
);
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Units Table
CREATE TABLE public.units (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    abbreviation text NOT NULL,
    CONSTRAINT units_pkey PRIMARY KEY (id),
    CONSTRAINT units_abbreviation_key UNIQUE (abbreviation),
    CONSTRAINT units_name_key UNIQUE (name)
);
ALTER TABLE public.units ENABLE ROW LEVEL SECURITY;

-- Categories Table (NEW)
CREATE TABLE public.categories (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    icon_name text,
    CONSTRAINT categories_pkey PRIMARY KEY (id),
    CONSTRAINT categories_name_key UNIQUE (name)
);
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

-- Products Table
CREATE TABLE public.products (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    sku text,
    hsn_code text,
    stock_quantity integer NOT NULL DEFAULT 0,
    unit_price numeric NOT NULL,
    tax_rate numeric NOT NULL,
    unit_id uuid,
    category_id uuid, -- Added foreign key for categories
    CONSTRAINT products_pkey PRIMARY KEY (id),
    CONSTRAINT products_stock_quantity_check CHECK (stock_quantity >= 0),
    CONSTRAINT products_unit_price_check CHECK (unit_price >= 0),
    CONSTRAINT products_tax_rate_check CHECK (tax_rate >= 0 AND tax_rate <= 1),
    CONSTRAINT products_sku_key UNIQUE (sku), -- SKU should be unique across all products
    CONSTRAINT products_sku_not_empty_check CHECK (sku IS NULL OR trim(sku) <> ''),
    CONSTRAINT products_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES public.units(id) ON DELETE SET NULL,
    CONSTRAINT products_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id) ON DELETE SET NULL
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

-- Purchases Table
CREATE TABLE public.purchases (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    product_id uuid NOT NULL,
    purchase_date date NOT NULL,
    reference_invoice text,
    quantity integer NOT NULL,
    CONSTRAINT purchases_pkey PRIMARY KEY (id),
    CONSTRAINT purchases_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE RESTRICT,
    CONSTRAINT purchases_quantity_check CHECK (quantity > 0)
);
ALTER TABLE public.purchases ENABLE ROW LEVEL SECURITY;

-- Invoices Table
CREATE TABLE public.invoices (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    customer_id uuid, -- Now nullable for guest/anonymous invoices
    invoice_number text NOT NULL,
    invoice_date date NOT NULL,
    notes text,
    total_amount numeric NOT NULL DEFAULT 0,
    CONSTRAINT invoices_pkey PRIMARY KEY (id),
    CONSTRAINT invoices_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customers(id) ON DELETE RESTRICT,
    CONSTRAINT invoices_invoice_number_key UNIQUE (invoice_number) -- Invoice number should be unique across all invoices
);
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

-- Invoice Items Table
CREATE TABLE public.invoice_items (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable, populated by trigger
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    invoice_id uuid NOT NULL,
    product_id uuid NOT NULL,
    quantity integer NOT NULL,
    unit_price numeric NOT NULL,
    tax_rate numeric NOT NULL,
    CONSTRAINT invoice_items_pkey PRIMARY KEY (id),
    CONSTRAINT invoice_items_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES public.invoices(id) ON DELETE CASCADE,
    CONSTRAINT invoice_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE RESTRICT,
    CONSTRAINT invoice_items_quantity_check CHECK (quantity > 0),
    CONSTRAINT invoice_items_unit_price_check CHECK (unit_price >= 0),
    CONSTRAINT invoice_items_tax_rate_check CHECK (tax_rate >= 0 AND tax_rate <= 1)
);
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;


-- 3. Functions and Triggers
-- These automate backend logic like calculations and data synchronization.

-- Function to set user_id on invoice_items from the parent invoice (will propagate NULL if parent is anonymous).
CREATE OR REPLACE FUNCTION public.set_invoice_item_user_id()
RETURNS TRIGGER AS $$
BEGIN
    SELECT user_id INTO NEW.user_id
    FROM public.invoices
    WHERE id = NEW.invoice_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for invoice_items user_id
CREATE TRIGGER before_invoice_item_insert
BEFORE INSERT ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.set_invoice_item_user_id();

-- Function to automatically calculate and update the total_amount on an invoice (INCREMENTAL)
CREATE OR REPLACE FUNCTION public.update_invoice_totals()
RETURNS TRIGGER AS $$
DECLARE
    old_item_total numeric;
    new_item_total numeric;
BEGIN
    IF (TG_OP = 'INSERT') THEN
        new_item_total := NEW.quantity * NEW.unit_price * (1 + NEW.tax_rate);
        UPDATE public.invoices SET total_amount = total_amount + new_item_total WHERE id = NEW.invoice_id;
        RETURN NULL;
    END IF;
    IF (TG_OP = 'DELETE') THEN
        old_item_total := OLD.quantity * OLD.unit_price * (1 + OLD.tax_rate);
        UPDATE public.invoices SET total_amount = total_amount - old_item_total WHERE id = OLD.invoice_id;
        RETURN NULL;
    END IF;
    IF (TG_OP = 'UPDATE') THEN
        old_item_total := OLD.quantity * OLD.unit_price * (1 + OLD.tax_rate);
        new_item_total := NEW.quantity * NEW.unit_price * (1 + NEW.tax_rate);
        IF OLD.invoice_id <> NEW.invoice_id THEN
            UPDATE public.invoices SET total_amount = total_amount - old_item_total WHERE id = OLD.invoice_id;
            UPDATE public.invoices SET total_amount = total_amount + new_item_total WHERE id = NEW.invoice_id;
        ELSE
            UPDATE public.invoices SET total_amount = total_amount - old_item_total + new_item_total WHERE id = NEW.invoice_id;
        END IF;
        RETURN NULL;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for invoice totals
CREATE TRIGGER on_invoice_item_change
AFTER INSERT OR UPDATE OR DELETE ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.update_invoice_totals();

-- Function to automatically update product stock levels when a purchase is recorded.
CREATE OR REPLACE FUNCTION public.update_stock_on_purchase()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE public.products SET stock_quantity = stock_quantity + NEW.quantity WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'UPDATE') THEN
        UPDATE public.products SET stock_quantity = stock_quantity - OLD.quantity + NEW.quantity WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE public.products SET stock_quantity = stock_quantity - OLD.quantity WHERE id = OLD.product_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for stock from purchases
CREATE TRIGGER on_purchase_change
AFTER INSERT OR UPDATE OR DELETE ON public.purchases
FOR EACH ROW
EXECUTE FUNCTION public.update_stock_on_purchase();

-- NEW: Function to update stock when an invoice item is created, updated, or deleted.
CREATE OR REPLACE FUNCTION public.update_stock_on_sale()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        -- Deduct stock when an item is added to an invoice
        UPDATE public.products
        SET stock_quantity = stock_quantity - NEW.quantity
        WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'DELETE') THEN
        -- Return stock when an item is removed from an invoice
        UPDATE public.products
        SET stock_quantity = stock_quantity + OLD.quantity
        WHERE id = OLD.product_id;
    ELSIF (TG_OP = 'UPDATE') THEN
        -- Handle changes in quantity or product for the same item
        IF OLD.product_id <> NEW.product_id THEN
            -- Product was changed: restore stock for the old product, deduct for the new one
            UPDATE public.products SET stock_quantity = stock_quantity + OLD.quantity WHERE id = OLD.product_id;
            UPDATE public.products SET stock_quantity = stock_quantity - NEW.quantity WHERE id = NEW.product_id;
        ELSE
            -- Only quantity changed: adjust stock for the same product
            UPDATE public.products
            SET stock_quantity = stock_quantity + OLD.quantity - NEW.quantity
            WHERE id = NEW.product_id;
        END IF;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- NEW: Trigger for stock from sales, replacing the old status-based logic.
CREATE TRIGGER on_sale_change
AFTER INSERT OR UPDATE OR DELETE ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.update_stock_on_sale();


-- Function to get a combined, paginated report of sales and purchases.
CREATE OR REPLACE FUNCTION get_combined_report(
    p_start_date date, p_end_date date, p_transaction_type text, p_limit integer, p_offset integer
)
RETURNS TABLE (
    transaction_id uuid, transaction_date date, transaction_type text,
    reference_number text, product_name text, quantity_change integer
) AS $$
BEGIN
    RETURN QUERY
    WITH combined_transactions AS (
        SELECT ii.id AS transaction_id, i.invoice_date, 'Sale' AS transaction_type, i.invoice_number, p.name, -ii.quantity
        FROM public.invoice_items ii
        JOIN public.invoices i ON ii.invoice_id = i.id
        JOIN public.products p ON ii.product_id = p.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'sale')
          AND i.invoice_date BETWEEN p_start_date AND p_end_date
        UNION ALL
        SELECT pu.id, pu.purchase_date, 'Purchase' AS transaction_type, pu.reference_invoice, p.name, pu.quantity
        FROM public.purchases pu
        JOIN public.products p ON pu.product_id = p.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'purchase')
          AND pu.purchase_date BETWEEN p_start_date AND p_end_date
    )
    SELECT * FROM combined_transactions
    ORDER BY transaction_date DESC, product_name ASC
    LIMIT p_limit OFFSET p_offset;
END;
$$ LANGUAGE plpgsql;

-- Function to get the total count for the combined report for pagination.
CREATE OR REPLACE FUNCTION get_combined_report_count(
    p_start_date date, p_end_date date, p_transaction_type text
)
RETURNS integer AS $$
DECLARE total_count integer;
BEGIN
    SELECT count(*) INTO total_count FROM (
        SELECT 1 FROM public.invoice_items ii
        JOIN public.invoices i ON ii.invoice_id = i.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'sale')
          AND i.invoice_date BETWEEN p_start_date AND p_end_date
        UNION ALL
        SELECT 1 FROM public.purchases pu
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'purchase')
          AND pu.purchase_date BETWEEN p_start_date AND p_end_date
    ) AS combined_transactions;
    RETURN total_count;
END;
$$ LANGUAGE plpgsql;


-- 4. Public Access Row Level Security Policies
-- WARNING: These policies grant full access to everyone.
CREATE POLICY "Enable public full access for company details" ON "public"."company_details" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all customers" ON "public"."customers" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all units" ON "public"."units" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all categories" ON "public"."categories" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all products" ON "public"."products" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all purchases" ON "public"."purchases" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all invoices" ON "public"."invoices" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all invoice items" ON "public"."invoice_items" FOR ALL TO public USING (true) WITH CHECK (true);


-- 5. Seed Data (Optional)
INSERT INTO public.categories (name, description, icon_name) VALUES
('Fertilizers', 'Nutrients for plant growth', 'Leaf'),
('Organic Fertilizers', 'Natural fertilizers derived from plant or animal matter', 'Sprout'),
('Chemical Fertilizers (Urea, DAP, NPK)', 'Synthetic fertilizers providing specific nutrients', 'FlaskConical'),
('Micronutrients', 'Essential elements required by plants in small quantities', 'TestTube2'),
('Pesticides & Crop Protection', 'Chemicals to control pests, diseases, and weeds', 'Shield'),
('Insecticides', 'Substances used to kill insects', 'Bug'),
('Fungicides', 'Biocidal chemical compounds used to kill parasitic fungi', 'SunSnow'),
('Herbicides', 'Substances that are toxic to plants, used to destroy unwanted vegetation', 'Ban'),
('Bio-Pesticides', 'Pesticides derived from natural materials like animals, plants, bacteria', 'Trees')
ON CONFLICT (name) DO UPDATE SET description = EXCLUDED.description, icon_name = EXCLUDED.icon_name;

-- 6. DEMO DATA (Optional, idempotent)
-- This block inserts sample units, customers, products, purchases, and invoices.
-- It's safe to run multiple times.

INSERT INTO public.units (name, abbreviation) VALUES 
('Pieces', 'PCS'),
('Kilogram', 'KG'),
('Litre', 'LTR'),
('Bottle', 'BTL'),
('Box', 'BOX'),
('Gram', 'GM'),
('Millilitre', 'ML')
ON CONFLICT (name) DO NOTHING;

DO $$
DECLARE
    -- Unit IDs
    kg_unit_id uuid;
    ltr_unit_id uuid;

    -- Category IDs
    chem_fertilizer_cat_id uuid;
    insecticide_cat_id uuid;
    fungicide_cat_id uuid;

    -- Customer IDs
    rohan_customer_id uuid;
    priya_customer_id uuid;

    -- Product IDs
    urea_prod_id uuid;
    dap_prod_id uuid;
    cyper_prod_id uuid;
    mancozeb_prod_id uuid;
    
    -- Invoice IDs
    inv1_id uuid;
    inv2_id uuid;

BEGIN
    -- Get Unit IDs
    SELECT id INTO kg_unit_id FROM public.units WHERE name = 'Kilogram';
    SELECT id INTO ltr_unit_id FROM public.units WHERE name = 'Litre';

    -- Get Category IDs
    SELECT id INTO chem_fertilizer_cat_id FROM public.categories WHERE name = 'Chemical Fertilizers (Urea, DAP, NPK)';
    SELECT id INTO insecticide_cat_id FROM public.categories WHERE name = 'Insecticides';
    SELECT id INTO fungicide_cat_id FROM public.categories WHERE name = 'Fungicides';

    -- Insert Customers and capture IDs
    INSERT INTO public.customers (name, phone, gstin, billing_address) VALUES ('Rohan Farm Supplies', '9876543210', '29ABCDE1234F1Z5', '123 Agri Lane, Market Road, Bengaluru') ON CONFLICT (name) DO NOTHING;
    SELECT id INTO rohan_customer_id FROM public.customers WHERE name = 'Rohan Farm Supplies';

    INSERT INTO public.customers (name, phone, gstin, billing_address) VALUES ('Priya Agro Store', '9123456780', '27FGHIJ5678K1Z9', '456 Kisan Chowk, Pune') ON CONFLICT (name) DO NOTHING;
    SELECT id INTO priya_customer_id FROM public.customers WHERE name = 'Priya Agro Store';

    -- Insert Products and capture IDs (stock_quantity starts at 0, will be updated by purchases)
    IF kg_unit_id IS NOT NULL AND chem_fertilizer_cat_id IS NOT NULL THEN
        INSERT INTO public.products (name, hsn_code, sku, unit_price, tax_rate, unit_id, category_id, stock_quantity) VALUES ('Urea (46% N)', '31021000', 'FER-UREA-50KG', 350.00, 0.05, kg_unit_id, chem_fertilizer_cat_id, 0) ON CONFLICT (sku) DO NOTHING;
    END IF;
    SELECT id INTO urea_prod_id FROM public.products WHERE sku = 'FER-UREA-50KG';
    
    IF kg_unit_id IS NOT NULL AND chem_fertilizer_cat_id IS NOT NULL THEN
        INSERT INTO public.products (name, hsn_code, sku, unit_price, tax_rate, unit_id, category_id, stock_quantity) VALUES ('DAP (18-46-0)', '31053000', 'FER-DAP-50KG', 1200.00, 0.05, kg_unit_id, chem_fertilizer_cat_id, 0) ON CONFLICT (sku) DO NOTHING;
    END IF;
    SELECT id INTO dap_prod_id FROM public.products WHERE sku = 'FER-DAP-50KG';

    IF ltr_unit_id IS NOT NULL AND insecticide_cat_id IS NOT NULL THEN
        INSERT INTO public.products (name, hsn_code, sku, unit_price, tax_rate, unit_id, category_id, stock_quantity) VALUES ('Cypermethrin 10% EC', '38089199', 'INS-CYPER-1LTR', 800.00, 0.18, ltr_unit_id, insecticide_cat_id, 0) ON CONFLICT (sku) DO NOTHING;
    END IF;
    SELECT id INTO cyper_prod_id FROM public.products WHERE sku = 'INS-CYPER-1LTR';

    IF kg_unit_id IS NOT NULL AND fungicide_cat_id IS NOT NULL THEN
        INSERT INTO public.products (name, hsn_code, sku, unit_price, tax_rate, unit_id, category_id, stock_quantity) VALUES ('Mancozeb 75% WP', '38089290', 'FUN-MANCO-1KG', 650.00, 0.18, kg_unit_id, fungicide_cat_id, 0) ON CONFLICT (sku) DO NOTHING;
    END IF;
    SELECT id INTO mancozeb_prod_id FROM public.products WHERE sku = 'FUN-MANCO-1KG';

    -- To ensure idempotency, we clear previous demo transactions
    DELETE FROM public.purchases WHERE reference_invoice IN ('PUR-2024-001', 'PUR-2024-002', 'PUR-2024-003');
    DELETE FROM public.invoices WHERE invoice_number IN ('INV-2024-001', 'INV-2024-002');
    
    -- Insert Purchases (This will trigger stock updates)
    IF urea_prod_id IS NOT NULL THEN
      INSERT INTO public.purchases (product_id, purchase_date, reference_invoice, quantity) VALUES (urea_prod_id, CURRENT_DATE - INTERVAL '15 days', 'PUR-2024-001', 100);
    END IF;
    IF dap_prod_id IS NOT NULL THEN
      INSERT INTO public.purchases (product_id, purchase_date, reference_invoice, quantity) VALUES (dap_prod_id, CURRENT_DATE - INTERVAL '14 days', 'PUR-2024-002', 50);
    END IF;
    IF cyper_prod_id IS NOT NULL THEN
      INSERT INTO public.purchases (product_id, purchase_date, reference_invoice, quantity) VALUES (cyper_prod_id, CURRENT_DATE - INTERVAL '10 days', 'PUR-2024-003', 30);
    END IF;
    IF mancozeb_prod_id IS NOT NULL THEN
      INSERT INTO public.purchases (product_id, purchase_date, reference_invoice, quantity) VALUES (mancozeb_prod_id, CURRENT_DATE - INTERVAL '10 days', 'PUR-2024-003', 40);
    END IF;

    -- Insert Invoices and capture IDs
    IF rohan_customer_id IS NOT NULL THEN
      INSERT INTO public.invoices (customer_id, invoice_number, invoice_date) VALUES (rohan_customer_id, 'INV-2024-001', CURRENT_DATE - INTERVAL '5 days') RETURNING id INTO inv1_id;
    END IF;
    
    IF priya_customer_id IS NOT NULL THEN
      INSERT INTO public.invoices (customer_id, invoice_number, invoice_date) VALUES (priya_customer_id, 'INV-2024-002', CURRENT_DATE - INTERVAL '2 days') RETURNING id INTO inv2_id;
    END IF;

    -- Insert Invoice Items (This will trigger stock updates and invoice total calculations)
    IF inv1_id IS NOT NULL AND urea_prod_id IS NOT NULL THEN
      INSERT INTO public.invoice_items (invoice_id, product_id, quantity, unit_price, tax_rate) VALUES (inv1_id, urea_prod_id, 10, 350.00, 0.05);
    END IF;
    IF inv1_id IS NOT NULL AND mancozeb_prod_id IS NOT NULL THEN
      INSERT INTO public.invoice_items (invoice_id, product_id, quantity, unit_price, tax_rate) VALUES (inv1_id, mancozeb_prod_id, 5, 650.00, 0.18);
    END IF;
    
    IF inv2_id IS NOT NULL AND dap_prod_id IS NOT NULL THEN
      INSERT INTO public.invoice_items (invoice_id, product_id, quantity, unit_price, tax_rate) VALUES (inv2_id, dap_prod_id, 8, 1200.00, 0.05);
    END IF;
    IF inv2_id IS NOT NULL AND cyper_prod_id IS NOT NULL THEN
      INSERT INTO public.invoice_items (invoice_id, product_id, quantity, unit_price, tax_rate) VALUES (inv2_id, cyper_prod_id, 2, 800.00, 0.18);
    END IF;

END $$;