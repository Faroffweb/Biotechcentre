-- Full Supabase Schema for a PUBLIC GST Management System
-- WARNING: This schema is designed for a fully public, anonymous-write database.
-- It removes user-specific data ownership, allowing ANYONE to create, read, update, and delete data.
-- Do NOT use this schema for sensitive or private data.
--
-- To use, copy and paste the entire script into the Supabase SQL Editor and run it.

-- 1. Tables
-- The `user_id` column is now nullable to allow anonymous data entry.

-- Company Details Table (SINGLETON)
CREATE TABLE public.company_details (
    id smallint NOT NULL DEFAULT 1,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text,
    address text,
    gstin text,
    pan text,
    account_name text,
    account_number text,
    account_type text,
    bank_name text,
    ifsc_code text,
    CONSTRAINT company_details_pkey PRIMARY KEY (id),
    CONSTRAINT company_details_singleton_check CHECK (id = 1)
);
ALTER TABLE public.company_details ENABLE ROW LEVEL SECURITY;

-- Customers Table
CREATE TABLE public.customers (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    email text,
    phone text,
    gstin text,
    billing_address text,
    is_guest boolean NOT NULL DEFAULT false,
    CONSTRAINT customers_pkey PRIMARY KEY (id)
);
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Units Table
CREATE TABLE public.units (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    abbreviation text NOT NULL,
    CONSTRAINT units_pkey PRIMARY KEY (id),
    CONSTRAINT units_abbreviation_key UNIQUE (abbreviation),
    CONSTRAINT units_name_key UNIQUE (name)
);
ALTER TABLE public.units ENABLE ROW LEVEL SECURITY;

-- Categories Table (NEW)
CREATE TABLE public.categories (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    icon_name text,
    CONSTRAINT categories_pkey PRIMARY KEY (id),
    CONSTRAINT categories_name_key UNIQUE (name)
);
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

-- Products Table
CREATE TABLE public.products (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    sku text,
    hsn_code text,
    stock_quantity integer NOT NULL DEFAULT 0,
    unit_price numeric NOT NULL,
    tax_rate numeric NOT NULL,
    unit_id uuid,
    category_id uuid, -- Added foreign key for categories
    CONSTRAINT products_pkey PRIMARY KEY (id),
    CONSTRAINT products_stock_quantity_check CHECK (stock_quantity >= 0),
    CONSTRAINT products_unit_price_check CHECK (unit_price >= 0),
    CONSTRAINT products_tax_rate_check CHECK (tax_rate >= 0 AND tax_rate <= 1),
    CONSTRAINT products_sku_key UNIQUE (sku), -- SKU should be unique across all products
    CONSTRAINT products_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES public.units(id) ON DELETE SET NULL,
    CONSTRAINT products_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id) ON DELETE SET NULL
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

-- Purchases Table
CREATE TABLE public.purchases (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    product_id uuid NOT NULL,
    purchase_date date NOT NULL,
    reference_invoice text,
    quantity integer NOT NULL,
    CONSTRAINT purchases_pkey PRIMARY KEY (id),
    CONSTRAINT purchases_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE RESTRICT,
    CONSTRAINT purchases_quantity_check CHECK (quantity > 0)
);
ALTER TABLE public.purchases ENABLE ROW LEVEL SECURITY;

-- Invoices Table
CREATE TABLE public.invoices (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    customer_id uuid, -- Now nullable for guest/anonymous invoices
    invoice_number text NOT NULL,
    invoice_date date NOT NULL,
    total_amount numeric NOT NULL DEFAULT 0,
    CONSTRAINT invoices_pkey PRIMARY KEY (id),
    CONSTRAINT invoices_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customers(id) ON DELETE RESTRICT,
    CONSTRAINT invoices_invoice_number_key UNIQUE (invoice_number) -- Invoice number should be unique across all invoices
);
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

-- Invoice Items Table
CREATE TABLE public.invoice_items (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable, populated by trigger
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    invoice_id uuid NOT NULL,
    product_id uuid NOT NULL,
    quantity integer NOT NULL,
    unit_price numeric NOT NULL,
    tax_rate numeric NOT NULL,
    CONSTRAINT invoice_items_pkey PRIMARY KEY (id),
    CONSTRAINT invoice_items_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES public.invoices(id) ON DELETE CASCADE,
    CONSTRAINT invoice_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE RESTRICT,
    CONSTRAINT invoice_items_quantity_check CHECK (quantity > 0),
    CONSTRAINT invoice_items_unit_price_check CHECK (unit_price >= 0),
    CONSTRAINT invoice_items_tax_rate_check CHECK (tax_rate >= 0 AND tax_rate <= 1)
);
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;


-- 3. Functions and Triggers
-- These automate backend logic like calculations and data synchronization.

-- Function to set user_id on invoice_items from the parent invoice (will propagate NULL if parent is anonymous).
CREATE OR REPLACE FUNCTION public.set_invoice_item_user_id()
RETURNS TRIGGER AS $$
BEGIN
    SELECT user_id INTO NEW.user_id
    FROM public.invoices
    WHERE id = NEW.invoice_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for invoice_items user_id
CREATE TRIGGER before_invoice_item_insert
BEFORE INSERT ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.set_invoice_item_user_id();

-- Function to automatically calculate and update the total_amount on an invoice (INCREMENTAL)
-- This function is optimized for performance. It performs incremental updates to the invoice's
-- total_amount, avoiding a full recalculation of all items. This ensures that even invoices
-- with many line items are updated efficiently.
CREATE OR REPLACE FUNCTION public.update_invoice_totals()
RETURNS TRIGGER AS $$
DECLARE
    old_item_total numeric;
    new_item_total numeric;
BEGIN
    -- On INSERT, add only the new item's total to the invoice total.
    IF (TG_OP = 'INSERT') THEN
        new_item_total := NEW.quantity * NEW.unit_price * (1 + NEW.tax_rate);
        UPDATE public.invoices
        SET total_amount = total_amount + new_item_total
        WHERE id = NEW.invoice_id;
        RETURN NULL;
    END IF;

    -- On DELETE, subtract only the old item's total from the invoice total.
    IF (TG_OP = 'DELETE') THEN
        old_item_total := OLD.quantity * OLD.unit_price * (1 + OLD.tax_rate);
        UPDATE public.invoices
        SET total_amount = total_amount - old_item_total
        WHERE id = OLD.invoice_id;
        RETURN NULL;
    END IF;

    -- On UPDATE, calculate the difference between the old and new item totals and apply it.
    IF (TG_OP = 'UPDATE') THEN
        old_item_total := OLD.quantity * OLD.unit_price * (1 + OLD.tax_rate);
        new_item_total := NEW.quantity * NEW.unit_price * (1 + NEW.tax_rate);

        -- If the item is moved to a different invoice, update both old and new invoices incrementally.
        IF OLD.invoice_id <> NEW.invoice_id THEN
            -- Subtract from the old invoice
            UPDATE public.invoices
            SET total_amount = total_amount - old_item_total
            WHERE id = OLD.invoice_id;

            -- Add to the new invoice
            UPDATE public.invoices
            SET total_amount = total_amount + new_item_total
            WHERE id = NEW.invoice_id;
        ELSE
            -- If the invoice is the same, just apply the difference for maximum efficiency.
            UPDATE public.invoices
            SET total_amount = total_amount - old_item_total + new_item_total
            WHERE id = NEW.invoice_id;
        END IF;
        RETURN NULL;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for invoice totals
CREATE TRIGGER on_invoice_item_change
AFTER INSERT OR UPDATE OR DELETE ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.update_invoice_totals();

-- Function to automatically update product stock levels when a purchase is recorded.
CREATE OR REPLACE FUNCTION public.update_stock_on_purchase()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE public.products
        SET stock_quantity = stock_quantity + NEW.quantity
        WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'UPDATE') THEN
        UPDATE public.products
        SET stock_quantity = stock_quantity - OLD.quantity + NEW.quantity
        WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE public.products
        SET stock_quantity = stock_quantity - OLD.quantity
        WHERE id = OLD.product_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for stock from purchases
CREATE TRIGGER on_purchase_change
AFTER INSERT OR UPDATE OR DELETE ON public.purchases
FOR EACH ROW
EXECUTE FUNCTION public.update_stock_on_purchase();


-- Function to automatically update product stock levels when an invoice item (sale) is recorded.
CREATE OR REPLACE FUNCTION public.update_stock_on_sale()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE public.products
        SET stock_quantity = stock_quantity - NEW.quantity
        WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'UPDATE') THEN
        UPDATE public.products
        SET stock_quantity = stock_quantity + OLD.quantity - NEW.quantity
        WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE public.products
        SET stock_quantity = stock_quantity + OLD.quantity
        WHERE id = OLD.product_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for stock from sales
CREATE TRIGGER on_invoice_item_sale
AFTER INSERT OR UPDATE OR DELETE ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.update_stock_on_sale();

-- Function to get a combined, paginated report of sales and purchases.
CREATE OR REPLACE FUNCTION get_combined_report(
    p_start_date date,
    p_end_date date,
    p_transaction_type text, -- 'all', 'sale', 'purchase'
    p_limit integer,
    p_offset integer
)
RETURNS TABLE (
    transaction_id uuid,
    transaction_date date,
    transaction_type text,
    reference_number text,
    product_name text,
    quantity_change integer,
    transaction_value numeric,
    details text
) AS $$
BEGIN
    RETURN QUERY
    WITH combined_transactions AS (
        -- Sales
        SELECT
            ii.id AS transaction_id,
            i.invoice_date AS transaction_date,
            'Sale' AS transaction_type,
            i.invoice_number AS reference_number,
            p.name AS product_name,
            -ii.quantity AS quantity_change,
            (ii.quantity * ii.unit_price) AS transaction_value,
            c.name AS details
        FROM public.invoice_items ii
        JOIN public.invoices i ON ii.invoice_id = i.id
        JOIN public.products p ON ii.product_id = p.id
        LEFT JOIN public.customers c ON i.customer_id = c.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'sale')
          AND i.invoice_date >= p_start_date
          AND i.invoice_date <= p_end_date

        UNION ALL

        -- Purchases
        SELECT
            pu.id AS transaction_id,
            pu.purchase_date AS transaction_date,
            'Purchase' AS transaction_type,
            pu.reference_invoice AS reference_number,
            p.name AS product_name,
            pu.quantity AS quantity_change,
            NULL AS transaction_value, -- No purchase price in schema
            'Stock In' AS details
        FROM public.purchases pu
        JOIN public.products p ON pu.product_id = p.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'purchase')
          AND pu.purchase_date >= p_start_date
          AND pu.purchase_date <= p_end_date
    )
    SELECT *
    FROM combined_transactions
    ORDER BY transaction_date DESC, product_name ASC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$ LANGUAGE plpgsql;

-- Function to get the total count for the combined report for pagination.
CREATE OR REPLACE FUNCTION get_combined_report_count(
    p_start_date date,
    p_end_date date,
    p_transaction_type text
)
RETURNS integer AS $$
DECLARE
    total_count integer;
BEGIN
    SELECT count(*) INTO total_count
    FROM (
        SELECT i.invoice_date
        FROM public.invoice_items ii
        JOIN public.invoices i ON ii.invoice_id = i.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'sale')
          AND i.invoice_date >= p_start_date
          AND i.invoice_date <= p_end_date

        UNION ALL

        SELECT pu.purchase_date
        FROM public.purchases pu
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'purchase')
          AND pu.purchase_date >= p_start_date
          AND pu.purchase_date <= p_end_date
    ) AS combined_transactions;

    RETURN total_count;
END;
$$ LANGUAGE plpgsql;

-- 4. Public Access Row Level Security Policies
-- WARNING: These policies grant full (SELECT, INSERT, UPDATE, DELETE) access to everyone, including unauthenticated visitors.
-- This effectively makes your database completely public and editable by anyone on the internet.

-- Public Full Access for Company Details
CREATE POLICY "Enable public full access for company details" ON "public"."company_details" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- Public Full Access for Customers
CREATE POLICY "Enable public full access for all customers" ON "public"."customers" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- Public Full Access for Units
CREATE POLICY "Enable public full access for all units" ON "public"."units" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- Public Full Access for Categories
CREATE POLICY "Enable public full access for all categories" ON "public"."categories" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- Public Full Access for Products
CREATE POLICY "Enable public full access for all products" ON "public"."products" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- Public Full Access for Purchases
CREATE POLICY "Enable public full access for all purchases" ON "public"."purchases" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- Public Full Access for Invoices
CREATE POLICY "Enable public full access for all invoices" ON "public"."invoices" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- Public Full Access for Invoice Items
CREATE POLICY "Enable public full access for all invoice items" ON "public"."invoice_items" AS PERMISSIVE FOR ALL TO public USING (true) WITH CHECK (true);

-- 5. Seed Data (Optional)
-- Pre-populate categories for agriculture
INSERT INTO public.categories (name, description, icon_name) VALUES
('Fertilizers', 'Nutrients for plant growth', 'Leaf'),
('Organic Fertilizers', 'Natural fertilizers derived from plant or animal matter', 'Sprout'),
('Chemical Fertilizers (Urea, DAP, NPK)', 'Synthetic fertilizers providing specific nutrients', 'FlaskConical'),
('Micronutrients', 'Essential elements required by plants in small quantities', 'TestTube2'),
('Pesticides & Crop Protection', 'Chemicals to control pests, diseases, and weeds', 'Shield'),
('Insecticides', 'Substances used to kill insects', 'Bug'),
('Fungicides', 'Biocidal chemical compounds used to kill parasitic fungi', 'SunSnow'),
('Herbicides', 'Substances that are toxic to plants, used to destroy unwanted vegetation', 'Ban'),
('Bio-Pesticides', 'Pesticides derived from natural materials like animals, plants, bacteria', 'Trees')
ON CONFLICT (name) DO UPDATE SET 
    description = EXCLUDED.description,
    icon_name = EXCLUDED.icon_name;