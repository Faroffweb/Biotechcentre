-- Full Supabase Schema for a PUBLIC GST Management System
-- WARNING: This schema is designed for a fully public, anonymous-write database.
-- It removes user-specific data ownership, allowing ANYONE to create, read, update, and delete data.
-- Do NOT use this schema for sensitive or private data.
--
-- To use, copy and paste the entire script into the Supabase SQL Editor and run it.

-- 0. Types
-- Create a new ENUM type for invoice statuses
CREATE TYPE public.invoice_status AS ENUM ('draft', 'sent', 'paid', 'cancelled');


-- 1. Tables
-- The `user_id` column is now nullable to allow anonymous data entry.

-- Company Details Table (SINGLETON)
CREATE TABLE public.company_details (
    id smallint NOT NULL DEFAULT 1,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text,
    address text,
    gstin text,
    pan text,
    account_name text,
    account_number text,
    account_type text,
    bank_name text,
    ifsc_code text,
    CONSTRAINT company_details_pkey PRIMARY KEY (id),
    CONSTRAINT company_details_singleton_check CHECK (id = 1)
);
ALTER TABLE public.company_details ENABLE ROW LEVEL SECURITY;

-- Customers Table
CREATE TABLE public.customers (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    email text,
    phone text,
    gstin text,
    billing_address text,
    is_guest boolean NOT NULL DEFAULT false,
    CONSTRAINT customers_pkey PRIMARY KEY (id)
);
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Units Table
CREATE TABLE public.units (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    abbreviation text NOT NULL,
    CONSTRAINT units_pkey PRIMARY KEY (id),
    CONSTRAINT units_abbreviation_key UNIQUE (abbreviation),
    CONSTRAINT units_name_key UNIQUE (name)
);
ALTER TABLE public.units ENABLE ROW LEVEL SECURITY;

-- Categories Table (NEW)
CREATE TABLE public.categories (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    icon_name text,
    CONSTRAINT categories_pkey PRIMARY KEY (id),
    CONSTRAINT categories_name_key UNIQUE (name)
);
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

-- Products Table
CREATE TABLE public.products (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    description text,
    sku text,
    hsn_code text,
    stock_quantity integer NOT NULL DEFAULT 0,
    unit_price numeric NOT NULL,
    tax_rate numeric NOT NULL,
    unit_id uuid,
    category_id uuid, -- Added foreign key for categories
    CONSTRAINT products_pkey PRIMARY KEY (id),
    CONSTRAINT products_stock_quantity_check CHECK (stock_quantity >= 0),
    CONSTRAINT products_unit_price_check CHECK (unit_price >= 0),
    CONSTRAINT products_tax_rate_check CHECK (tax_rate >= 0 AND tax_rate <= 1),
    CONSTRAINT products_sku_key UNIQUE (sku), -- SKU should be unique across all products
    CONSTRAINT products_sku_not_empty_check CHECK (sku IS NULL OR trim(sku) <> ''),
    CONSTRAINT products_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES public.units(id) ON DELETE SET NULL,
    CONSTRAINT products_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id) ON DELETE SET NULL
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

-- Purchases Table
CREATE TABLE public.purchases (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    product_id uuid NOT NULL,
    purchase_date date NOT NULL,
    reference_invoice text,
    quantity integer NOT NULL,
    CONSTRAINT purchases_pkey PRIMARY KEY (id),
    CONSTRAINT purchases_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE RESTRICT,
    CONSTRAINT purchases_quantity_check CHECK (quantity > 0)
);
ALTER TABLE public.purchases ENABLE ROW LEVEL SECURITY;

-- Invoices Table
CREATE TABLE public.invoices (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable for public access
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    customer_id uuid, -- Now nullable for guest/anonymous invoices
    invoice_number text NOT NULL,
    invoice_date date NOT NULL,
    total_amount numeric NOT NULL DEFAULT 0,
    status public.invoice_status NOT NULL DEFAULT 'draft', -- Added status column
    CONSTRAINT invoices_pkey PRIMARY KEY (id),
    CONSTRAINT invoices_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customers(id) ON DELETE RESTRICT,
    CONSTRAINT invoices_invoice_number_key UNIQUE (invoice_number) -- Invoice number should be unique across all invoices
);
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

-- Invoice Items Table
CREATE TABLE public.invoice_items (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    user_id uuid, -- Made nullable, populated by trigger
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    invoice_id uuid NOT NULL,
    product_id uuid NOT NULL,
    quantity integer NOT NULL,
    unit_price numeric NOT NULL,
    tax_rate numeric NOT NULL,
    CONSTRAINT invoice_items_pkey PRIMARY KEY (id),
    CONSTRAINT invoice_items_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES public.invoices(id) ON DELETE CASCADE,
    CONSTRAINT invoice_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE RESTRICT,
    CONSTRAINT invoice_items_quantity_check CHECK (quantity > 0),
    CONSTRAINT invoice_items_unit_price_check CHECK (unit_price >= 0),
    CONSTRAINT invoice_items_tax_rate_check CHECK (tax_rate >= 0 AND tax_rate <= 1)
);
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;


-- 3. Functions and Triggers
-- These automate backend logic like calculations and data synchronization.

-- Function to set user_id on invoice_items from the parent invoice (will propagate NULL if parent is anonymous).
CREATE OR REPLACE FUNCTION public.set_invoice_item_user_id()
RETURNS TRIGGER AS $$
BEGIN
    SELECT user_id INTO NEW.user_id
    FROM public.invoices
    WHERE id = NEW.invoice_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for invoice_items user_id
CREATE TRIGGER before_invoice_item_insert
BEFORE INSERT ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.set_invoice_item_user_id();

-- Function to automatically calculate and update the total_amount on an invoice (INCREMENTAL)
CREATE OR REPLACE FUNCTION public.update_invoice_totals()
RETURNS TRIGGER AS $$
DECLARE
    old_item_total numeric;
    new_item_total numeric;
BEGIN
    IF (TG_OP = 'INSERT') THEN
        new_item_total := NEW.quantity * NEW.unit_price * (1 + NEW.tax_rate);
        UPDATE public.invoices SET total_amount = total_amount + new_item_total WHERE id = NEW.invoice_id;
        RETURN NULL;
    END IF;
    IF (TG_OP = 'DELETE') THEN
        old_item_total := OLD.quantity * OLD.unit_price * (1 + OLD.tax_rate);
        UPDATE public.invoices SET total_amount = total_amount - old_item_total WHERE id = OLD.invoice_id;
        RETURN NULL;
    END IF;
    IF (TG_OP = 'UPDATE') THEN
        old_item_total := OLD.quantity * OLD.unit_price * (1 + OLD.tax_rate);
        new_item_total := NEW.quantity * NEW.unit_price * (1 + NEW.tax_rate);
        IF OLD.invoice_id <> NEW.invoice_id THEN
            UPDATE public.invoices SET total_amount = total_amount - old_item_total WHERE id = OLD.invoice_id;
            UPDATE public.invoices SET total_amount = total_amount + new_item_total WHERE id = NEW.invoice_id;
        ELSE
            UPDATE public.invoices SET total_amount = total_amount - old_item_total + new_item_total WHERE id = NEW.invoice_id;
        END IF;
        RETURN NULL;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for invoice totals
CREATE TRIGGER on_invoice_item_change
AFTER INSERT OR UPDATE OR DELETE ON public.invoice_items
FOR EACH ROW
EXECUTE FUNCTION public.update_invoice_totals();

-- Function to automatically update product stock levels when a purchase is recorded.
CREATE OR REPLACE FUNCTION public.update_stock_on_purchase()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE public.products SET stock_quantity = stock_quantity + NEW.quantity WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'UPDATE') THEN
        UPDATE public.products SET stock_quantity = stock_quantity - OLD.quantity + NEW.quantity WHERE id = NEW.product_id;
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE public.products SET stock_quantity = stock_quantity - OLD.quantity WHERE id = OLD.product_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger for stock from purchases
CREATE TRIGGER on_purchase_change
AFTER INSERT OR UPDATE OR DELETE ON public.purchases
FOR EACH ROW
EXECUTE FUNCTION public.update_stock_on_purchase();


-- NEW: Function to adjust stock based on INVOICE STATUS changes.
CREATE OR REPLACE FUNCTION public.handle_invoice_status_change()
RETURNS TRIGGER AS $$
DECLARE
    item RECORD;
BEGIN
    -- Do nothing if status hasn't changed
    IF OLD.status = NEW.status THEN
        RETURN NULL;
    END IF;
    -- Stock Deduction: Moving TO a 'finalized' state (sent, paid) from a non-finalized state
    IF NEW.status IN ('sent', 'paid') AND OLD.status NOT IN ('sent', 'paid') THEN
        FOR item IN SELECT product_id, quantity FROM public.invoice_items WHERE invoice_id = NEW.id LOOP
            UPDATE public.products
            SET stock_quantity = stock_quantity - item.quantity
            WHERE id = item.product_id;
        END LOOP;
    END IF;
    -- Stock Return: Moving FROM a 'finalized' state to a non-finalized state
    IF OLD.status IN ('sent', 'paid') AND NEW.status NOT IN ('sent', 'paid') THEN
         FOR item IN SELECT product_id, quantity FROM public.invoice_items WHERE invoice_id = NEW.id LOOP
            UPDATE public.products
            SET stock_quantity = stock_quantity + item.quantity
            WHERE id = item.product_id;
        END LOOP;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- NEW: Trigger for invoice status change
CREATE TRIGGER on_invoice_status_change
AFTER UPDATE ON public.invoices
FOR EACH ROW
EXECUTE FUNCTION public.handle_invoice_status_change();


-- NEW: Function to return stock when a finalized INVOICE is DELETED.
CREATE OR REPLACE FUNCTION public.return_stock_on_invoice_delete()
RETURNS TRIGGER AS $$
DECLARE
    item RECORD;
BEGIN
    -- Only return stock if the deleted invoice was in a 'finalized' state
    IF OLD.status IN ('sent', 'paid') THEN
        FOR item IN SELECT product_id, quantity FROM public.invoice_items WHERE invoice_id = OLD.id LOOP
            UPDATE public.products
            SET stock_quantity = stock_quantity + item.quantity
            WHERE id = item.product_id;
        END LOOP;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- NEW: Trigger for invoice deletion
CREATE TRIGGER on_invoice_delete
BEFORE DELETE ON public.invoices
FOR EACH ROW
EXECUTE FUNCTION public.return_stock_on_invoice_delete();


-- Function to get a combined, paginated report of sales and purchases.
CREATE OR REPLACE FUNCTION get_combined_report(
    p_start_date date, p_end_date date, p_transaction_type text, p_limit integer, p_offset integer
)
RETURNS TABLE (
    transaction_id uuid, transaction_date date, transaction_type text,
    reference_number text, product_name text, quantity_change integer
) AS $$
BEGIN
    RETURN QUERY
    WITH combined_transactions AS (
        SELECT ii.id AS transaction_id, i.invoice_date, 'Sale' AS transaction_type, i.invoice_number, p.name, -ii.quantity
        FROM public.invoice_items ii
        JOIN public.invoices i ON ii.invoice_id = i.id
        JOIN public.products p ON ii.product_id = p.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'sale')
          AND i.status IN ('sent', 'paid') -- Only count sales from finalized invoices
          AND i.invoice_date BETWEEN p_start_date AND p_end_date
        UNION ALL
        SELECT pu.id, pu.purchase_date, 'Purchase' AS transaction_type, pu.reference_invoice, p.name, pu.quantity
        FROM public.purchases pu
        JOIN public.products p ON pu.product_id = p.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'purchase')
          AND pu.purchase_date BETWEEN p_start_date AND p_end_date
    )
    SELECT * FROM combined_transactions
    ORDER BY transaction_date DESC, product_name ASC
    LIMIT p_limit OFFSET p_offset;
END;
$$ LANGUAGE plpgsql;

-- Function to get the total count for the combined report for pagination.
CREATE OR REPLACE FUNCTION get_combined_report_count(
    p_start_date date, p_end_date date, p_transaction_type text
)
RETURNS integer AS $$
DECLARE total_count integer;
BEGIN
    SELECT count(*) INTO total_count FROM (
        SELECT 1 FROM public.invoice_items ii
        JOIN public.invoices i ON ii.invoice_id = i.id
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'sale')
          AND i.status IN ('sent', 'paid') -- Only count sales from finalized invoices
          AND i.invoice_date BETWEEN p_start_date AND p_end_date
        UNION ALL
        SELECT 1 FROM public.purchases pu
        WHERE (p_transaction_type = 'all' OR p_transaction_type = 'purchase')
          AND pu.purchase_date BETWEEN p_start_date AND p_end_date
    ) AS combined_transactions;
    RETURN total_count;
END;
$$ LANGUAGE plpgsql;


-- 4. Public Access Row Level Security Policies
-- WARNING: These policies grant full access to everyone.
CREATE POLICY "Enable public full access for company details" ON "public"."company_details" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all customers" ON "public"."customers" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all units" ON "public"."units" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all categories" ON "public"."categories" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all products" ON "public"."products" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all purchases" ON "public"."purchases" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all invoices" ON "public"."invoices" FOR ALL TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable public full access for all invoice items" ON "public"."invoice_items" FOR ALL TO public USING (true) WITH CHECK (true);


-- 5. Seed Data (Optional)
INSERT INTO public.categories (name, description, icon_name) VALUES
('Fertilizers', 'Nutrients for plant growth', 'Leaf'),
('Organic Fertilizers', 'Natural fertilizers derived from plant or animal matter', 'Sprout'),
('Chemical Fertilizers (Urea, DAP, NPK)', 'Synthetic fertilizers providing specific nutrients', 'FlaskConical'),
('Micronutrients', 'Essential elements required by plants in small quantities', 'TestTube2'),
('Pesticides & Crop Protection', 'Chemicals to control pests, diseases, and weeds', 'Shield'),
('Insecticides', 'Substances used to kill insects', 'Bug'),
('Fungicides', 'Biocidal chemical compounds used to kill parasitic fungi', 'SunSnow'),
('Herbicides', 'Substances that are toxic to plants, used to destroy unwanted vegetation', 'Ban'),
('Bio-Pesticides', 'Pesticides derived from natural materials like animals, plants, bacteria', 'Trees')
ON CONFLICT (name) DO UPDATE SET description = EXCLUDED.description, icon_name = EXCLUDED.icon_name;